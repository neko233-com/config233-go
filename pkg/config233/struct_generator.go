package config233

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"unicode"

	"github.com/xuri/excelize/v2"
)

// StructGenerator Excel 配置 Struct 代码生成器
type StructGenerator struct {
	outputDir string
}

// NewStructGenerator 创建新的 Struct 生成器
func NewStructGenerator(outputDir string) *StructGenerator {
	return &StructGenerator{
		outputDir: outputDir,
	}
}

// GenerateFromExcel 从 Excel 文件生成 Go struct
func (g *StructGenerator) GenerateFromExcel(excelPath string) error {
	f, err := excelize.OpenFile(excelPath)
	if err != nil {
		return fmt.Errorf("打开 Excel 文件失败: %w", err)
	}
	defer f.Close()

	// 获取第一个工作表
	sheets := f.GetSheetList()
	if len(sheets) == 0 {
		return fmt.Errorf("Excel 文件没有工作表")
	}
	sheetName := sheets[0]

	rows, err := f.GetRows(sheetName)
	if err != nil {
		return fmt.Errorf("读取工作表失败: %w", err)
	}

	// 固定行结构
	const (
		typeRowIndex   = 3 // 类型行（第 4 行）
		serverRowIndex = 4 // Server 字段名行（第 5 行）
	)

	if len(rows) <= serverRowIndex {
		return fmt.Errorf("Excel 行数不足，需要至少 %d 行", serverRowIndex+1)
	}

	// 获取配置名（从文件名）
	baseName := filepath.Base(excelPath)
	configName := strings.TrimSuffix(baseName, filepath.Ext(baseName))
	structName := g.toStructName(configName)

	// 获取字段信息
	typeRow := rows[typeRowIndex]
	serverRow := rows[serverRowIndex]

	var fields []FieldInfo
	// 从第 2 列开始（跳过标识列）
	for i := 1; i < len(serverRow); i++ {
		fieldName := serverRow[i]
		if fieldName == "" {
			continue
		}

		var fieldType string
		if i < len(typeRow) {
			fieldType = typeRow[i]
		}

		fields = append(fields, FieldInfo{
			Name:      fieldName,
			ExcelType: fieldType,
			GoType:    g.excelTypeToGoType(fieldType),
		})
	}

	// 生成代码
	code := g.generateStructCode(structName, configName, fields)

	// 确保输出目录存在
	if err := os.MkdirAll(g.outputDir, 0755); err != nil {
		return fmt.Errorf("创建输出目录失败: %w", err)
	}

	// 写入文件
	outputPath := filepath.Join(g.outputDir, configName+".go")
	if err := os.WriteFile(outputPath, []byte(code), 0644); err != nil {
		return fmt.Errorf("写入文件失败: %w", err)
	}

	return nil
}

// GenerateFromDir 从目录下的所有 Excel 文件生成 struct
func (g *StructGenerator) GenerateFromDir(dir string) error {
	return filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() {
			return nil
		}

		ext := strings.ToLower(filepath.Ext(path))
		if ext == ".xlsx" || ext == ".xls" {
			// 跳过 Excel 临时文件
			if strings.HasPrefix(filepath.Base(path), "~$") {
				return nil
			}

			if err := g.GenerateFromExcel(path); err != nil {
				getLogger().Error(err, "生成 struct 失败", "file", path)
				// 继续处理其他文件
			} else {
				getLogger().Info("生成 struct 成功", "file", path)
			}
		}

		return nil
	})
}

// FieldInfo 字段信息
type FieldInfo struct {
	Name      string // Server 字段名
	ExcelType string // Excel 中的类型
	GoType    string // Go 类型
}

// excelTypeToGoType 将 Excel 类型转换为 Go 类型
func (g *StructGenerator) excelTypeToGoType(excelType string) string {
	switch strings.ToLower(excelType) {
	case "int", "int32":
		return "int"
	case "long", "int64":
		return "int64"
	case "float", "float32":
		return "float32"
	case "double", "float64":
		return "float64"
	case "bool", "boolean":
		return "bool"
	case "json":
		return "string" // JSON 保持为字符串
	case "string", "":
		return "string"
	default:
		return "string"
	}
}

// toStructName 将配置名转为 struct 名（完全保持配置名大小写，无视 Go 导出规范）
func (g *StructGenerator) toStructName(name string) string {
	return name
}

// toFieldName 将字段名转为 Go 字段名（首字母大写）
func (g *StructGenerator) toFieldName(name string) string {
	if len(name) == 0 {
		return name
	}
	runes := []rune(name)
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}

// isKvConfig 检查是否是 KV 配置（名字包含 Kv，不区分大小写）
func (g *StructGenerator) isKvConfig(name string) bool {
	return strings.Contains(strings.ToLower(name), "kv")
}

// hasValueField 检查字段列表中是否有 value/Value/val/Val 字段
func (g *StructGenerator) findValueField(fields []FieldInfo) string {
	for _, f := range fields {
		lower := strings.ToLower(f.Name)
		if lower == "value" || lower == "val" {
			return f.Name
		}
	}
	return ""
}

// generateStructCode 生成 struct 代码
func (g *StructGenerator) generateStructCode(structName, configName string, fields []FieldInfo) string {
	var sb strings.Builder

	// 包声明和导入
	sb.WriteString("// Code generated by config233. DO NOT EDIT.\n")
	sb.WriteString("// Source: " + configName + ".xlsx\n\n")
	sb.WriteString("package generated\n\n")

	// 检查是否是 KV 配置，如果是则需要导入 config233
	isKv := g.isKvConfig(configName)
	valueField := ""
	if isKv {
		valueField = g.findValueField(fields)
		if valueField == "" {
			// 如果没有 value 字段，默认使用第二个字段（假设第一个是 id）
			if len(fields) > 1 {
				valueField = fields[1].Name
			}
		}
		if valueField != "" {
			sb.WriteString("import \"github.com/neko233-com/config233-go/pkg/config233\"\n\n")
		}
	}

	// 生成 struct
	sb.WriteString(fmt.Sprintf("// %s 配置结构体\n", structName))
	sb.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	for _, field := range fields {
		fieldName := g.toFieldName(field.Name)
		// 添加 json tag
		sb.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, field.GoType, field.Name))
	}

	sb.WriteString("}\n")

	// 如果是 KV 配置，生成 IKvConfig 接口实现
	if isKv && valueField != "" {
		sb.WriteString("\n")
		sb.WriteString(fmt.Sprintf("// Ensure %s implements IKvConfig interface\n", structName))
		sb.WriteString(fmt.Sprintf("var _ config233.IKvConfig = (*%s)(nil)\n\n", structName))
		sb.WriteString("// GetValue 实现 IKvConfig 接口\n")
		sb.WriteString(fmt.Sprintf("func (c *%s) GetValue() string {\n", structName))

		// 根据字段类型生成返回代码
		var fieldType string
		for _, f := range fields {
			if f.Name == valueField {
				fieldType = f.GoType
				break
			}
		}

		fieldGoName := g.toFieldName(valueField)
		switch fieldType {
		case "string":
			sb.WriteString(fmt.Sprintf("\treturn c.%s\n", fieldGoName))
		case "int", "int32", "int64":
			sb.WriteString(fmt.Sprintf("\treturn strconv.FormatInt(int64(c.%s), 10)\n", fieldGoName))
		case "float32", "float64":
			sb.WriteString(fmt.Sprintf("\treturn strconv.FormatFloat(float64(c.%s), 'f', -1, 64)\n", fieldGoName))
		case "bool":
			sb.WriteString(fmt.Sprintf("\treturn strconv.FormatBool(c.%s)\n", fieldGoName))
		default:
			sb.WriteString(fmt.Sprintf("\treturn c.%s\n", fieldGoName))
		}

		sb.WriteString("}\n")

		// 需要导入 strconv
		if fieldType != "string" {
			// 重新生成带 import 的代码
			return g.generateStructCodeWithImport(structName, configName, fields, valueField, fieldType)
		}
	}

	return sb.String()
}

// generateStructCodeWithImport 生成带 import 的 struct 代码
func (g *StructGenerator) generateStructCodeWithImport(structName, configName string, fields []FieldInfo, valueField, valueFieldType string) string {
	var sb strings.Builder

	// 包声明和导入
	sb.WriteString("// Code generated by config233. DO NOT EDIT.\n")
	sb.WriteString("// Source: " + configName + ".xlsx\n\n")
	sb.WriteString("package generated\n\n")
	sb.WriteString("import (\n")
	sb.WriteString("\t\"strconv\"\n\n")
	sb.WriteString("\t\"github.com/neko233-com/config233-go/pkg/config233\"\n")
	sb.WriteString(")\n\n")

	// 生成 struct
	sb.WriteString(fmt.Sprintf("// %s 配置结构体\n", structName))
	sb.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	for _, field := range fields {
		fieldName := g.toFieldName(field.Name)
		sb.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, field.GoType, field.Name))
	}

	sb.WriteString("}\n")

	// IKvConfig 接口实现
	sb.WriteString("\n")
	sb.WriteString(fmt.Sprintf("// Ensure %s implements IKvConfig interface\n", structName))
	sb.WriteString(fmt.Sprintf("var _ config233.IKvConfig = (*%s)(nil)\n\n", structName))
	sb.WriteString("// GetValue 实现 IKvConfig 接口\n")
	sb.WriteString(fmt.Sprintf("func (c *%s) GetValue() string {\n", structName))

	fieldGoName := g.toFieldName(valueField)
	switch valueFieldType {
	case "int", "int32", "int64":
		sb.WriteString(fmt.Sprintf("\treturn strconv.FormatInt(int64(c.%s), 10)\n", fieldGoName))
	case "float32", "float64":
		sb.WriteString(fmt.Sprintf("\treturn strconv.FormatFloat(float64(c.%s), 'f', -1, 64)\n", fieldGoName))
	case "bool":
		sb.WriteString(fmt.Sprintf("\treturn strconv.FormatBool(c.%s)\n", fieldGoName))
	default:
		sb.WriteString(fmt.Sprintf("\treturn c.%s\n", fieldGoName))
	}

	sb.WriteString("}\n")

	return sb.String()
}

// GenerateStructsFromExcelDir 便捷函数：从 Excel 目录生成 struct 到指定输出目录
func GenerateStructsFromExcelDir(excelDir, outputDir string) error {
	generator := NewStructGenerator(outputDir)
	return generator.GenerateFromDir(excelDir)
}

// GenerateStructFromExcel 便捷函数：从单个 Excel 文件生成 struct
func GenerateStructFromExcel(excelPath, outputDir string) error {
	generator := NewStructGenerator(outputDir)
	return generator.GenerateFromExcel(excelPath)
}
